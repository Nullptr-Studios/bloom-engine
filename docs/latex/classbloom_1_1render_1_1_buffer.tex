\doxysection{bloom\+::render\+::Buffer Class Reference}
\hypertarget{classbloom_1_1render_1_1_buffer}{}\label{classbloom_1_1render_1_1_buffer}\index{bloom::render::Buffer@{bloom::render::Buffer}}


Represents a Vulkan buffer object.  




{\ttfamily \#include $<$buffer.\+hpp$>$}

\doxysubsubsection*{Public Member Functions}
\begin{DoxyCompactItemize}
\item 
\mbox{\hyperlink{classbloom_1_1render_1_1_buffer_ab59a7b083b80bd4590d9544ea0881528}{Buffer}} (\mbox{\hyperlink{classbloom_1_1render_1_1_devices}{Devices}} \&device, Vk\+Device\+Size instance\+Size, uint32\+\_\+t instance\+Count, Vk\+Buffer\+Usage\+Flags usage\+Flags, Vk\+Memory\+Property\+Flags memory\+Property\+Flags, Vk\+Device\+Size min\+Offset\+Alignment=1)
\begin{DoxyCompactList}\small\item\em Constructs a new \doxylink{classbloom_1_1render_1_1_buffer}{Buffer} object. \end{DoxyCompactList}\item 
\Hypertarget{classbloom_1_1render_1_1_buffer_a46e49658dd8b654763bbacdc503cf7b8}\label{classbloom_1_1render_1_1_buffer_a46e49658dd8b654763bbacdc503cf7b8} 
{\bfseries Buffer} (const \mbox{\hyperlink{classbloom_1_1render_1_1_buffer}{Buffer}} \&)=delete
\item 
\Hypertarget{classbloom_1_1render_1_1_buffer_ae226db9886b73da08a97ebdea4dfb67e}\label{classbloom_1_1render_1_1_buffer_ae226db9886b73da08a97ebdea4dfb67e} 
\mbox{\hyperlink{classbloom_1_1render_1_1_buffer}{Buffer}} \& {\bfseries operator=} (const \mbox{\hyperlink{classbloom_1_1render_1_1_buffer}{Buffer}} \&)=delete
\item 
Vk\+Result \mbox{\hyperlink{classbloom_1_1render_1_1_buffer_a7ae53712d6cecefcab4a6a6cef15f479}{Map}} (Vk\+Device\+Size size=VK\+\_\+\+WHOLE\+\_\+\+SIZE, Vk\+Device\+Size offset=0)
\item 
void \mbox{\hyperlink{classbloom_1_1render_1_1_buffer_ad879b72fed8b6ec31817c131d77a3d59}{Unmap}} ()
\item 
void \mbox{\hyperlink{classbloom_1_1render_1_1_buffer_a0cf9a4f4601e1b9ad3ce7088389ab280}{Write\+To\+Buffer}} (const void \texorpdfstring{$\ast$}{*}data, Vk\+Device\+Size size=VK\+\_\+\+WHOLE\+\_\+\+SIZE, Vk\+Device\+Size offset=0) const
\item 
Vk\+Result \mbox{\hyperlink{classbloom_1_1render_1_1_buffer_ad26ff9c30a4af9e282f656c6e43bc079}{Flush}} (Vk\+Device\+Size size=VK\+\_\+\+WHOLE\+\_\+\+SIZE, Vk\+Device\+Size offset=0) const
\item 
Vk\+Descriptor\+Buffer\+Info \mbox{\hyperlink{classbloom_1_1render_1_1_buffer_a27c3f8d3cd0783a898bf5c9182c0af2e}{Descriptor\+Info}} (Vk\+Device\+Size size=VK\+\_\+\+WHOLE\+\_\+\+SIZE, Vk\+Device\+Size offset=0) const
\item 
Vk\+Result \mbox{\hyperlink{classbloom_1_1render_1_1_buffer_a36e803348215c1e9f77b19904d972782}{Invalidate}} (Vk\+Device\+Size size=VK\+\_\+\+WHOLE\+\_\+\+SIZE, Vk\+Device\+Size offset=0) const
\item 
void \mbox{\hyperlink{classbloom_1_1render_1_1_buffer_a483f6d1116280335c393c3b9279cbf84}{Write\+To\+Index}} (const void \texorpdfstring{$\ast$}{*}data, int index) const
\item 
Vk\+Result \mbox{\hyperlink{classbloom_1_1render_1_1_buffer_ad71290962a21cff1f52297b7d36d513b}{Flush\+Index}} (int index) const
\item 
Vk\+Descriptor\+Buffer\+Info \mbox{\hyperlink{classbloom_1_1render_1_1_buffer_a0fc49b289e38255664a5e4f923153a9c}{Descriptor\+Info\+For\+Index}} (int index) const
\item 
Vk\+Result \mbox{\hyperlink{classbloom_1_1render_1_1_buffer_a51d8262ba644571121418537321c9975}{Invalidate\+Index}} (int index) const
\item 
Vk\+Buffer \mbox{\hyperlink{classbloom_1_1render_1_1_buffer_a73341ea81eed91349d5834c84706dc4f}{Get\+Buffer}} () const
\begin{DoxyCompactList}\small\item\em Gets the underlying Vulkan buffer handle. \end{DoxyCompactList}\item 
void \texorpdfstring{$\ast$}{*} \mbox{\hyperlink{classbloom_1_1render_1_1_buffer_a01db35c212166c5248c1a0fbab50464a}{Get\+Mapped\+Memory}} () const
\begin{DoxyCompactList}\small\item\em Gets a pointer to the mapped memory of the buffer. \end{DoxyCompactList}\item 
uint32\+\_\+t \mbox{\hyperlink{classbloom_1_1render_1_1_buffer_a383200e76caefc2418af37a68aa5baf3}{Get\+Instance\+Count}} () const
\begin{DoxyCompactList}\small\item\em Gets the number of instances stored in the buffer. \end{DoxyCompactList}\item 
Vk\+Device\+Size \mbox{\hyperlink{classbloom_1_1render_1_1_buffer_a483aab638696775a174276d0ce0c74d5}{Get\+Instance\+Size}} () const
\begin{DoxyCompactList}\small\item\em Gets the size of a single instance in the buffer. \end{DoxyCompactList}\item 
Vk\+Device\+Size \mbox{\hyperlink{classbloom_1_1render_1_1_buffer_a9a8f1a63feb3a35cde70b2bd276ca71a}{Get\+Alignment\+Size}} () const
\begin{DoxyCompactList}\small\item\em Gets the alignment size used for instances in the buffer. \end{DoxyCompactList}\item 
Vk\+Buffer\+Usage\+Flags \mbox{\hyperlink{classbloom_1_1render_1_1_buffer_a63f4efce69629ee0f5e256cc97abb737}{Get\+Usage\+Flags}} () const
\begin{DoxyCompactList}\small\item\em Gets the usage flags specified for the buffer. \end{DoxyCompactList}\item 
Vk\+Memory\+Property\+Flags \mbox{\hyperlink{classbloom_1_1render_1_1_buffer_adce436cf0c7200a4aacd4b43e4d586e0}{Get\+Memory\+Property\+Flags}} () const
\begin{DoxyCompactList}\small\item\em Gets the memory property flags specified for the buffer. \end{DoxyCompactList}\item 
Vk\+Device\+Size \mbox{\hyperlink{classbloom_1_1render_1_1_buffer_a1d7fa44111d719d7df9fad4cc5d5eb84}{Get\+Buffer\+Size}} () const
\begin{DoxyCompactList}\small\item\em Gets the total size of the buffer in bytes. \end{DoxyCompactList}\end{DoxyCompactItemize}


\doxysubsection{Detailed Description}
Represents a Vulkan buffer object. 

This class encapsulates a Vulkan buffer and its associated memory, providing methods for data manipulation and interaction with the Vulkan API. It supports storing multiple instances of data within a single buffer, and provides convenience methods for accessing individual instances. 

\doxysubsection{Constructor \& Destructor Documentation}
\Hypertarget{classbloom_1_1render_1_1_buffer_ab59a7b083b80bd4590d9544ea0881528}\index{bloom::render::Buffer@{bloom::render::Buffer}!Buffer@{Buffer}}
\index{Buffer@{Buffer}!bloom::render::Buffer@{bloom::render::Buffer}}
\doxysubsubsection{\texorpdfstring{Buffer()}{Buffer()}}
{\footnotesize\ttfamily \label{classbloom_1_1render_1_1_buffer_ab59a7b083b80bd4590d9544ea0881528} 
bloom\+::render\+::\+Buffer\+::\+Buffer (\begin{DoxyParamCaption}\item[{\mbox{\hyperlink{classbloom_1_1render_1_1_devices}{Devices}} \&}]{device}{, }\item[{Vk\+Device\+Size}]{instance\+Size}{, }\item[{uint32\+\_\+t}]{instance\+Count}{, }\item[{Vk\+Buffer\+Usage\+Flags}]{usage\+Flags}{, }\item[{Vk\+Memory\+Property\+Flags}]{memory\+Property\+Flags}{, }\item[{Vk\+Device\+Size}]{min\+Offset\+Alignment}{ = {\ttfamily 1}}\end{DoxyParamCaption})}



Constructs a new \doxylink{classbloom_1_1render_1_1_buffer}{Buffer} object. 

Creates a new Vulkan buffer with the specified parameters.


\begin{DoxyParams}{Parameters}
{\em device} & Reference to the {\ttfamily \doxylink{classbloom_1_1render_1_1_devices}{Devices}} object. \\
\hline
{\em instance\+Size} & The size of a single instance in the buffer (in bytes). \\
\hline
{\em instance\+Count} & The number of instances to allocate in the buffer. \\
\hline
{\em usage\+Flags} & Vulkan buffer usage flags (e.\+g., VK\+\_\+\+BUFFER\+\_\+\+USAGE\+\_\+\+VERTEX\+\_\+\+BUFFER\+\_\+\+BIT). \\
\hline
{\em memory\+Property\+Flags} & Vulkan memory property flags (e.\+g., VK\+\_\+\+MEMORY\+\_\+\+PROPERTY\+\_\+\+HOST\+\_\+\+VISIBLE\+\_\+\+BIT). \\
\hline
{\em min\+Offset\+Alignment} & Minimum required alignment for buffer offsets. This parameter is crucial when using buffers with descriptors that have offset restrictions. \\
\hline
\end{DoxyParams}


\doxysubsection{Member Function Documentation}
\Hypertarget{classbloom_1_1render_1_1_buffer_a27c3f8d3cd0783a898bf5c9182c0af2e}\index{bloom::render::Buffer@{bloom::render::Buffer}!DescriptorInfo@{DescriptorInfo}}
\index{DescriptorInfo@{DescriptorInfo}!bloom::render::Buffer@{bloom::render::Buffer}}
\doxysubsubsection{\texorpdfstring{DescriptorInfo()}{DescriptorInfo()}}
{\footnotesize\ttfamily \label{classbloom_1_1render_1_1_buffer_a27c3f8d3cd0783a898bf5c9182c0af2e} 
Vk\+Descriptor\+Buffer\+Info bloom\+::render\+::\+Buffer\+::\+Descriptor\+Info (\begin{DoxyParamCaption}\item[{Vk\+Device\+Size}]{size}{ = {\ttfamily VK\+\_\+WHOLE\+\_\+SIZE}, }\item[{Vk\+Device\+Size}]{offset}{ = {\ttfamily 0}}\end{DoxyParamCaption}) const}

Create a buffer info descriptor


\begin{DoxyParams}{Parameters}
{\em size} & (Optional) Size of the memory range of the descriptor \\
\hline
{\em offset} & (Optional) Byte offset from beginning\\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
Vk\+Descriptor\+Buffer\+Info of specified offset and range 
\end{DoxyReturn}
\Hypertarget{classbloom_1_1render_1_1_buffer_a0fc49b289e38255664a5e4f923153a9c}\index{bloom::render::Buffer@{bloom::render::Buffer}!DescriptorInfoForIndex@{DescriptorInfoForIndex}}
\index{DescriptorInfoForIndex@{DescriptorInfoForIndex}!bloom::render::Buffer@{bloom::render::Buffer}}
\doxysubsubsection{\texorpdfstring{DescriptorInfoForIndex()}{DescriptorInfoForIndex()}}
{\footnotesize\ttfamily \label{classbloom_1_1render_1_1_buffer_a0fc49b289e38255664a5e4f923153a9c} 
Vk\+Descriptor\+Buffer\+Info bloom\+::render\+::\+Buffer\+::\+Descriptor\+Info\+For\+Index (\begin{DoxyParamCaption}\item[{int}]{index}{}\end{DoxyParamCaption}) const}

Create a buffer info descriptor


\begin{DoxyParams}{Parameters}
{\em index} & Specifies the region\+\_\+ given by index x alignment\+Size\\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
Vk\+Descriptor\+Buffer\+Info for instance at index 
\end{DoxyReturn}
\Hypertarget{classbloom_1_1render_1_1_buffer_ad26ff9c30a4af9e282f656c6e43bc079}\index{bloom::render::Buffer@{bloom::render::Buffer}!Flush@{Flush}}
\index{Flush@{Flush}!bloom::render::Buffer@{bloom::render::Buffer}}
\doxysubsubsection{\texorpdfstring{Flush()}{Flush()}}
{\footnotesize\ttfamily \label{classbloom_1_1render_1_1_buffer_ad26ff9c30a4af9e282f656c6e43bc079} 
Vk\+Result bloom\+::render\+::\+Buffer\+::\+Flush (\begin{DoxyParamCaption}\item[{Vk\+Device\+Size}]{size}{ = {\ttfamily VK\+\_\+WHOLE\+\_\+SIZE}, }\item[{Vk\+Device\+Size}]{offset}{ = {\ttfamily 0}}\end{DoxyParamCaption}) const}

Flush a memory range of the buffer to make it visible to the device

\begin{DoxyNote}{Note}
Only required for non-\/coherent memory
\end{DoxyNote}

\begin{DoxyParams}{Parameters}
{\em size} & (Optional) Size of the memory range to flush. Pass VK\+\_\+\+WHOLE\+\_\+\+SIZE to flush the complete buffer range. \\
\hline
{\em offset} & (Optional) Byte offset from beginning\\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
Vk\+Result of the flush call 
\end{DoxyReturn}
\Hypertarget{classbloom_1_1render_1_1_buffer_ad71290962a21cff1f52297b7d36d513b}\index{bloom::render::Buffer@{bloom::render::Buffer}!FlushIndex@{FlushIndex}}
\index{FlushIndex@{FlushIndex}!bloom::render::Buffer@{bloom::render::Buffer}}
\doxysubsubsection{\texorpdfstring{FlushIndex()}{FlushIndex()}}
{\footnotesize\ttfamily \label{classbloom_1_1render_1_1_buffer_ad71290962a21cff1f52297b7d36d513b} 
Vk\+Result bloom\+::render\+::\+Buffer\+::\+Flush\+Index (\begin{DoxyParamCaption}\item[{int}]{index}{}\end{DoxyParamCaption}) const}

Flush the memory range at index \texorpdfstring{$\ast$}{*} alignment\+Size of the buffer to make it visible to the device


\begin{DoxyParams}{Parameters}
{\em index} & Used in offset calculation \\
\hline
\end{DoxyParams}
\Hypertarget{classbloom_1_1render_1_1_buffer_a9a8f1a63feb3a35cde70b2bd276ca71a}\index{bloom::render::Buffer@{bloom::render::Buffer}!GetAlignmentSize@{GetAlignmentSize}}
\index{GetAlignmentSize@{GetAlignmentSize}!bloom::render::Buffer@{bloom::render::Buffer}}
\doxysubsubsection{\texorpdfstring{GetAlignmentSize()}{GetAlignmentSize()}}
{\footnotesize\ttfamily \label{classbloom_1_1render_1_1_buffer_a9a8f1a63feb3a35cde70b2bd276ca71a} 
Vk\+Device\+Size bloom\+::render\+::\+Buffer\+::\+Get\+Alignment\+Size (\begin{DoxyParamCaption}{}{}\end{DoxyParamCaption}) const\hspace{0.3cm}{\ttfamily [inline]}}



Gets the alignment size used for instances in the buffer. 

This represents the alignment requirement, in bytes, for each instance in the buffer. This value is likely the same as the instance size, but it\textquotesingle{}s important to distinguish between them. It is recommended to review whether a separate alignment member is needed, or if this function should simply return the instance size. This function currently returns the same value as {\ttfamily \doxylink{classbloom_1_1render_1_1_buffer_a483aab638696775a174276d0ce0c74d5}{Get\+Instance\+Size()}}.

\begin{DoxyReturn}{Returns}
The alignment size in bytes. 
\end{DoxyReturn}
\Hypertarget{classbloom_1_1render_1_1_buffer_a73341ea81eed91349d5834c84706dc4f}\index{bloom::render::Buffer@{bloom::render::Buffer}!GetBuffer@{GetBuffer}}
\index{GetBuffer@{GetBuffer}!bloom::render::Buffer@{bloom::render::Buffer}}
\doxysubsubsection{\texorpdfstring{GetBuffer()}{GetBuffer()}}
{\footnotesize\ttfamily \label{classbloom_1_1render_1_1_buffer_a73341ea81eed91349d5834c84706dc4f} 
Vk\+Buffer bloom\+::render\+::\+Buffer\+::\+Get\+Buffer (\begin{DoxyParamCaption}{}{}\end{DoxyParamCaption}) const\hspace{0.3cm}{\ttfamily [inline]}}



Gets the underlying Vulkan buffer handle. 

This handle represents the Vulkan buffer object that stores the data. It\textquotesingle{}s used by Vulkan for various operations like binding the buffer to a command buffer and transferring data.

\begin{DoxyReturn}{Returns}
The Vulkan buffer handle. 
\end{DoxyReturn}
\Hypertarget{classbloom_1_1render_1_1_buffer_a1d7fa44111d719d7df9fad4cc5d5eb84}\index{bloom::render::Buffer@{bloom::render::Buffer}!GetBufferSize@{GetBufferSize}}
\index{GetBufferSize@{GetBufferSize}!bloom::render::Buffer@{bloom::render::Buffer}}
\doxysubsubsection{\texorpdfstring{GetBufferSize()}{GetBufferSize()}}
{\footnotesize\ttfamily \label{classbloom_1_1render_1_1_buffer_a1d7fa44111d719d7df9fad4cc5d5eb84} 
Vk\+Device\+Size bloom\+::render\+::\+Buffer\+::\+Get\+Buffer\+Size (\begin{DoxyParamCaption}{}{}\end{DoxyParamCaption}) const\hspace{0.3cm}{\ttfamily [inline]}}



Gets the total size of the buffer in bytes. 

This represents the total allocated size of the buffer.

\begin{DoxyReturn}{Returns}
The buffer size. 
\end{DoxyReturn}
\Hypertarget{classbloom_1_1render_1_1_buffer_a383200e76caefc2418af37a68aa5baf3}\index{bloom::render::Buffer@{bloom::render::Buffer}!GetInstanceCount@{GetInstanceCount}}
\index{GetInstanceCount@{GetInstanceCount}!bloom::render::Buffer@{bloom::render::Buffer}}
\doxysubsubsection{\texorpdfstring{GetInstanceCount()}{GetInstanceCount()}}
{\footnotesize\ttfamily \label{classbloom_1_1render_1_1_buffer_a383200e76caefc2418af37a68aa5baf3} 
uint32\+\_\+t bloom\+::render\+::\+Buffer\+::\+Get\+Instance\+Count (\begin{DoxyParamCaption}{}{}\end{DoxyParamCaption}) const\hspace{0.3cm}{\ttfamily [inline]}}



Gets the number of instances stored in the buffer. 

This represents the number of individual data elements (instances) contained within the buffer. For example, if the buffer stores vertex data, this would be the number of vertices.

\begin{DoxyReturn}{Returns}
The instance count. 
\end{DoxyReturn}
\Hypertarget{classbloom_1_1render_1_1_buffer_a483aab638696775a174276d0ce0c74d5}\index{bloom::render::Buffer@{bloom::render::Buffer}!GetInstanceSize@{GetInstanceSize}}
\index{GetInstanceSize@{GetInstanceSize}!bloom::render::Buffer@{bloom::render::Buffer}}
\doxysubsubsection{\texorpdfstring{GetInstanceSize()}{GetInstanceSize()}}
{\footnotesize\ttfamily \label{classbloom_1_1render_1_1_buffer_a483aab638696775a174276d0ce0c74d5} 
Vk\+Device\+Size bloom\+::render\+::\+Buffer\+::\+Get\+Instance\+Size (\begin{DoxyParamCaption}{}{}\end{DoxyParamCaption}) const\hspace{0.3cm}{\ttfamily [inline]}}



Gets the size of a single instance in the buffer. 

This represents the size, in bytes, of each individual data element within the buffer.

\begin{DoxyReturn}{Returns}
The size of an instance in bytes. 
\end{DoxyReturn}
\Hypertarget{classbloom_1_1render_1_1_buffer_a01db35c212166c5248c1a0fbab50464a}\index{bloom::render::Buffer@{bloom::render::Buffer}!GetMappedMemory@{GetMappedMemory}}
\index{GetMappedMemory@{GetMappedMemory}!bloom::render::Buffer@{bloom::render::Buffer}}
\doxysubsubsection{\texorpdfstring{GetMappedMemory()}{GetMappedMemory()}}
{\footnotesize\ttfamily \label{classbloom_1_1render_1_1_buffer_a01db35c212166c5248c1a0fbab50464a} 
void \texorpdfstring{$\ast$}{*} bloom\+::render\+::\+Buffer\+::\+Get\+Mapped\+Memory (\begin{DoxyParamCaption}{}{}\end{DoxyParamCaption}) const\hspace{0.3cm}{\ttfamily [inline]}}



Gets a pointer to the mapped memory of the buffer. 

This provides direct access to the CPU-\/accessible memory region\+\_\+ where the buffer\textquotesingle{}s data resides. This pointer can be used to write or read data directly from the buffer.

\begin{DoxyReturn}{Returns}
A pointer to the mapped memory. This pointer will be {\ttfamily nullptr} if the buffer is not mapped. 
\end{DoxyReturn}
\Hypertarget{classbloom_1_1render_1_1_buffer_adce436cf0c7200a4aacd4b43e4d586e0}\index{bloom::render::Buffer@{bloom::render::Buffer}!GetMemoryPropertyFlags@{GetMemoryPropertyFlags}}
\index{GetMemoryPropertyFlags@{GetMemoryPropertyFlags}!bloom::render::Buffer@{bloom::render::Buffer}}
\doxysubsubsection{\texorpdfstring{GetMemoryPropertyFlags()}{GetMemoryPropertyFlags()}}
{\footnotesize\ttfamily \label{classbloom_1_1render_1_1_buffer_adce436cf0c7200a4aacd4b43e4d586e0} 
Vk\+Memory\+Property\+Flags bloom\+::render\+::\+Buffer\+::\+Get\+Memory\+Property\+Flags (\begin{DoxyParamCaption}{}{}\end{DoxyParamCaption}) const\hspace{0.3cm}{\ttfamily [inline]}}



Gets the memory property flags specified for the buffer. 

These flags define the memory properties of the buffer (e.\+g., host visible, host coherent, device local, etc.).

\begin{DoxyReturn}{Returns}
The memory property flags. These are Vulkan {\ttfamily Vk\+Memory\+Property\+Flag\+Bits} values. 
\end{DoxyReturn}
\Hypertarget{classbloom_1_1render_1_1_buffer_a63f4efce69629ee0f5e256cc97abb737}\index{bloom::render::Buffer@{bloom::render::Buffer}!GetUsageFlags@{GetUsageFlags}}
\index{GetUsageFlags@{GetUsageFlags}!bloom::render::Buffer@{bloom::render::Buffer}}
\doxysubsubsection{\texorpdfstring{GetUsageFlags()}{GetUsageFlags()}}
{\footnotesize\ttfamily \label{classbloom_1_1render_1_1_buffer_a63f4efce69629ee0f5e256cc97abb737} 
Vk\+Buffer\+Usage\+Flags bloom\+::render\+::\+Buffer\+::\+Get\+Usage\+Flags (\begin{DoxyParamCaption}{}{}\end{DoxyParamCaption}) const\hspace{0.3cm}{\ttfamily [inline]}}



Gets the usage flags specified for the buffer. 

These flags define how the buffer will be used by Vulkan (e.\+g., vertex buffer, index buffer, uniform buffer, etc.).

\begin{DoxyReturn}{Returns}
The buffer usage flags. These are Vulkan {\ttfamily Vk\+Buffer\+Usage\+Flag\+Bits} values. 
\end{DoxyReturn}
\Hypertarget{classbloom_1_1render_1_1_buffer_a36e803348215c1e9f77b19904d972782}\index{bloom::render::Buffer@{bloom::render::Buffer}!Invalidate@{Invalidate}}
\index{Invalidate@{Invalidate}!bloom::render::Buffer@{bloom::render::Buffer}}
\doxysubsubsection{\texorpdfstring{Invalidate()}{Invalidate()}}
{\footnotesize\ttfamily \label{classbloom_1_1render_1_1_buffer_a36e803348215c1e9f77b19904d972782} 
Vk\+Result bloom\+::render\+::\+Buffer\+::\+Invalidate (\begin{DoxyParamCaption}\item[{Vk\+Device\+Size}]{size}{ = {\ttfamily VK\+\_\+WHOLE\+\_\+SIZE}, }\item[{Vk\+Device\+Size}]{offset}{ = {\ttfamily 0}}\end{DoxyParamCaption}) const}

Invalidate a memory range of the buffer to make it visible to the host

\begin{DoxyNote}{Note}
Only required for non-\/coherent memory
\end{DoxyNote}

\begin{DoxyParams}{Parameters}
{\em size} & (Optional) Size of the memory range to invalidate. Pass VK\+\_\+\+WHOLE\+\_\+\+SIZE to invalidate the complete buffer range. \\
\hline
{\em offset} & (Optional) Byte offset from beginning\\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
Vk\+Result of the invalidate call 
\end{DoxyReturn}
\Hypertarget{classbloom_1_1render_1_1_buffer_a51d8262ba644571121418537321c9975}\index{bloom::render::Buffer@{bloom::render::Buffer}!InvalidateIndex@{InvalidateIndex}}
\index{InvalidateIndex@{InvalidateIndex}!bloom::render::Buffer@{bloom::render::Buffer}}
\doxysubsubsection{\texorpdfstring{InvalidateIndex()}{InvalidateIndex()}}
{\footnotesize\ttfamily \label{classbloom_1_1render_1_1_buffer_a51d8262ba644571121418537321c9975} 
Vk\+Result bloom\+::render\+::\+Buffer\+::\+Invalidate\+Index (\begin{DoxyParamCaption}\item[{int}]{index}{}\end{DoxyParamCaption}) const}

Invalidate a memory range of the buffer to make it visible to the host

\begin{DoxyNote}{Note}
Only required for non-\/coherent memory
\end{DoxyNote}

\begin{DoxyParams}{Parameters}
{\em index} & Specifies the region\+\_\+ to invalidate\+: index x alignment\+Size\\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
Vk\+Result of the invalidate call 
\end{DoxyReturn}
\Hypertarget{classbloom_1_1render_1_1_buffer_a7ae53712d6cecefcab4a6a6cef15f479}\index{bloom::render::Buffer@{bloom::render::Buffer}!Map@{Map}}
\index{Map@{Map}!bloom::render::Buffer@{bloom::render::Buffer}}
\doxysubsubsection{\texorpdfstring{Map()}{Map()}}
{\footnotesize\ttfamily \label{classbloom_1_1render_1_1_buffer_a7ae53712d6cecefcab4a6a6cef15f479} 
Vk\+Result bloom\+::render\+::\+Buffer\+::\+Map (\begin{DoxyParamCaption}\item[{Vk\+Device\+Size}]{size}{ = {\ttfamily VK\+\_\+WHOLE\+\_\+SIZE}, }\item[{Vk\+Device\+Size}]{offset}{ = {\ttfamily 0}}\end{DoxyParamCaption})}

Map a memory range of this buffer. If successful, mapped points to the specified buffer range.


\begin{DoxyParams}{Parameters}
{\em size} & (Optional) Size of the memory range to map. Pass VK\+\_\+\+WHOLE\+\_\+\+SIZE to map the complete buffer range. \\
\hline
{\em offset} & (Optional) Byte offset from beginning\\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
Vk\+Result of the buffer mapping call 
\end{DoxyReturn}
\Hypertarget{classbloom_1_1render_1_1_buffer_ad879b72fed8b6ec31817c131d77a3d59}\index{bloom::render::Buffer@{bloom::render::Buffer}!Unmap@{Unmap}}
\index{Unmap@{Unmap}!bloom::render::Buffer@{bloom::render::Buffer}}
\doxysubsubsection{\texorpdfstring{Unmap()}{Unmap()}}
{\footnotesize\ttfamily \label{classbloom_1_1render_1_1_buffer_ad879b72fed8b6ec31817c131d77a3d59} 
void bloom\+::render\+::\+Buffer\+::\+Unmap (\begin{DoxyParamCaption}{}{}\end{DoxyParamCaption})}

Unmap a mapped memory range

\begin{DoxyNote}{Note}
Does not return a result as vk\+Unmap\+Memory can\textquotesingle{}t fail 
\end{DoxyNote}
\Hypertarget{classbloom_1_1render_1_1_buffer_a0cf9a4f4601e1b9ad3ce7088389ab280}\index{bloom::render::Buffer@{bloom::render::Buffer}!WriteToBuffer@{WriteToBuffer}}
\index{WriteToBuffer@{WriteToBuffer}!bloom::render::Buffer@{bloom::render::Buffer}}
\doxysubsubsection{\texorpdfstring{WriteToBuffer()}{WriteToBuffer()}}
{\footnotesize\ttfamily \label{classbloom_1_1render_1_1_buffer_a0cf9a4f4601e1b9ad3ce7088389ab280} 
void bloom\+::render\+::\+Buffer\+::\+Write\+To\+Buffer (\begin{DoxyParamCaption}\item[{const void \texorpdfstring{$\ast$}{*}}]{data}{, }\item[{Vk\+Device\+Size}]{size}{ = {\ttfamily VK\+\_\+WHOLE\+\_\+SIZE}, }\item[{Vk\+Device\+Size}]{offset}{ = {\ttfamily 0}}\end{DoxyParamCaption}) const}

Copies the specified data to the mapped buffer. Default value writes whole buffer range


\begin{DoxyParams}{Parameters}
{\em data} & Pointer to the data to copy \\
\hline
{\em size} & (Optional) Size of the data to copy. Pass VK\+\_\+\+WHOLE\+\_\+\+SIZE to flush the complete buffer range. \\
\hline
{\em offset} & (Optional) Byte offset from beginning of mapped region \\
\hline
\end{DoxyParams}
\Hypertarget{classbloom_1_1render_1_1_buffer_a483f6d1116280335c393c3b9279cbf84}\index{bloom::render::Buffer@{bloom::render::Buffer}!WriteToIndex@{WriteToIndex}}
\index{WriteToIndex@{WriteToIndex}!bloom::render::Buffer@{bloom::render::Buffer}}
\doxysubsubsection{\texorpdfstring{WriteToIndex()}{WriteToIndex()}}
{\footnotesize\ttfamily \label{classbloom_1_1render_1_1_buffer_a483f6d1116280335c393c3b9279cbf84} 
void bloom\+::render\+::\+Buffer\+::\+Write\+To\+Index (\begin{DoxyParamCaption}\item[{const void \texorpdfstring{$\ast$}{*}}]{data}{, }\item[{int}]{index}{}\end{DoxyParamCaption}) const}

Copies "{}instance\+Size"{} bytes of data to the mapped buffer at an offset of index \texorpdfstring{$\ast$}{*} alignment\+Size


\begin{DoxyParams}{Parameters}
{\em data} & Pointer to the data to copy \\
\hline
{\em index} & Used in offset calculation \\
\hline
\end{DoxyParams}


The documentation for this class was generated from the following files\+:\begin{DoxyCompactItemize}
\item 
C\+:/\+Users/xgoni/bloom/bloom/src/render/\mbox{\hyperlink{buffer_8hpp}{buffer.\+hpp}}\item 
C\+:/\+Users/xgoni/bloom/bloom/src/render/buffer.\+cpp\end{DoxyCompactItemize}
